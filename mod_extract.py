"""
RDLT Modified Activity Extraction Module

This module provides functionality for extracting and analyzing activity profiles from RDLTs.
It offers a comprehensive approach to analyzing RDLT traversal patterns, join structures, 
and cycle traversability, providing insights into how RDLT behave during execution.

The module implements:
- Activity profile extraction from RDLTs
- Analysis of arc traversability based on join conditions
- Path finding and cycle handling mechanisms
- Simulation of RDLT traversal to identify potential deadlocks

Activity profiles represent the step-by-step execution of the RDLT, showing which arcs are traversed
at each timestep, whether the sink is reached, and any violations that may occur during traversal.
"""

from collections import defaultdict
import utils

class ModifiedActivityExtraction:
    """
    A class for analyzing and extracting activity profiles from RDLTs.
    
    This class performs in-depth analysis of RDLTs to determine how arcs would be traversed
    during execution, including handling special structures like joins and cycles. It classifies 
    join vertices, checks their traversability, and simulates arc traversal to identify potential
    issues like deadlocks.
    
    Activity profiles generated by this class show the step-by-step traversal of arcs, whether
    the sink vertex is successfully reached, and any violations that might occur during traversal.
    
    Attributes:
        R (list): The list of arcs in the RDLT.
        contraction_path (dict): Information about contraction paths in the RDLT.
        violations (list): List of detected violations in the RDLT.
        cycle_list (list): List of cycles detected in the RDLT.
        failed_contractions (set): Set of arcs that failed contraction.
        source (str): The source vertex of the RDLT.
        sink (str): The sink vertex of the RDLT.
        checked_arcs (set): Set of arcs that have been checked for traversability.
        traversed_arcs (set): Set of arcs that have been traversed during profile extraction.
        arc_traversal_count (defaultdict): Count of how many times each arc has been traversed.
        max_traversal_depth (int): Maximum depth for traversal to prevent infinite loops.
        join_vertices (set): Set of vertices that are joins (have multiple incoming arcs).
        join_classifications (dict): Classification of join vertices by type.
        activity_profiles (dict): Dictionary of extracted activity profiles.
    """

    def __init__(self, R, violations=None, contraction_path=None, cycle_list=None):
        """
        Initialize the ModifiedActivityExtraction with RDLT data (EVSA) and analysis results.
        
        Parameters:
            R (list): List of arcs in the RDLT, where each arc is a dictionary with
                      at least an 'arc' key containing the edge as "vertex1, vertex2".
            violations (list, optional): List of detected violations in the RDLT.
            contraction_path (dict, optional): Dictionary of contraction paths.
            cycle_list (list, optional): List of cycles detected in the RDLT.
        """
        self.R = R
        self.contraction_path = contraction_path or []
        self.violations = violations or []
        self.cycle_list = cycle_list or []
        self.failed_contractions = set()
        for path_info in self.contraction_path.values():
            for fc in path_info.get('failed_contractions', []):
                self.failed_contractions.add(self.get_arc(fc))

        
        self.source, self.sink = utils.get_source_and_target_vertices(self.R)

        self.checked_arcs = set()
        self.traversed_arcs = set()
        self.arc_traversal_count = defaultdict(int)
        self.max_traversal_depth = len(self.R) * 3

        self.join_vertices = self.identify_join_vertices()
        self.join_classifications = self.classify_joins()

        self.activity_profiles = {}

    def identify_join_vertices(self):
        """
        Identify vertices with multiple incoming arcs.
        
        This method scans through all arcs in the RDLT to find vertices that have
        more than one incoming arc. These vertices are potential join points in the RDLT.
        
        Returns:
            set: A set of vertices that have multiple incoming arcs.
        """
        incoming_count = defaultdict(int)
        for arc in self.R:
            try:
                _, target = self.get_arc(arc).split(', ')
                incoming_count[target] += 1
            except Exception:
                continue
        
        return {v for v, count in incoming_count.items() if count > 1}

    def classify_joins(self):
        """
        Classify join vertices as AND-JOIN, OR-JOIN, or MIX-JOIN based on their C-attributes.
        
        This method analyzes each join vertex to determine its type based on the C-attributes
        of its incoming arcs:
        - AND-JOIN: At least one incoming arc has a non-epsilon (sigma) C-attribute
        - OR-JOIN: All incoming arcs have epsilon C-attributes
        - MIX-JOIN: Some incoming arcs have non-epsilon (sigma) C-attributes and some have epsilon C-attributes
        Returns:
            dict: A dictionary mapping join vertices to their classifications, where each
                 classification is a dict with keys 'type' and 'incoming_arcs'.
        """
        join_classifications = {}
        
        for vertex in sorted(self.join_vertices):  # Sort vertices for deterministic processing
            incoming_arcs = [
                arc for arc in self.R if self.get_arc(arc).endswith(f", {vertex}")
            ]
            
            # Sort for deterministic processing
            incoming_arcs.sort(key=lambda arc: self.get_arc(arc))
            
            c_attrs = [self.get_c_attribute(arc) for arc in incoming_arcs]
            non_epsilon = [c for c in c_attrs if c != '0']

            if len(set(c_attrs)) <= 1:
                join_type = 'OR-JOIN'
            elif len(non_epsilon) == len(c_attrs):
                join_type = 'AND-JOIN'
            else:
                join_type = 'MIX-JOIN'

            join_classifications[vertex] = {
                'type': join_type, 
                'incoming_arcs': incoming_arcs, 
                'c_attributes': c_attrs
            }
        
        return join_classifications

    def is_vertex_reachable(self, vertex, depth=0):
        """
        Check if a vertex is reachable by traversing the RDLT.
        
        This method determines if a vertex can be visited from the current state of the RDLT
        by accounting for L-attributes (traversal limits) and following valid paths.
        
        Parameters:
            vertex (str): The vertex to check for reachability.
            depth (int, optional): Current recursion depth to prevent infinite loops.
        
        Returns:
            bool: True if the vertex is reachable, False otherwise.
        """
        if depth > len(self.R) * 2:
            return False

        if vertex == self.source:
            return True
        
        for path in self.contraction_path.values():
            if vertex in [v.split(', ')[0] for v in path.get('contracted_path', [])]:
                return True
        
        checked_sources = set()
        
        for arc in self.R:
            arc_str = self.get_arc(arc)
            source, target = arc_str.split(', ')
            
            if target == vertex:
                if arc_str in self.traversed_arcs:
                    return True
                
                if source not in checked_sources:
                    checked_sources.add(source)
                    if self.is_vertex_reachable(source, depth + 1):
                        return True
        
        return False

    def is_vertex_reachable_from_source(self, vertex, visited=None):
        """
        Check if a vertex is reachable from the source vertex.
        
        This method determines if there is a valid path from the source vertex to the
        specified vertex while respecting L-attributes and other RDLT constraints.
        
        Parameters:
            vertex (str): The vertex to check for reachability from source.
            visited (set, optional): Set of already visited vertices to prevent cycles. Defaults to None.
        
        Returns:
            bool: True if the vertex is reachable from source, False otherwise.
        """
        if visited is None:
            visited = set()
        
        # Base cases
        if vertex == self.source:
            return True
        
        if vertex in visited:
            return False  # Already visited, avoid cycles
        
        visited.add(vertex)
        
        # Check if this vertex is in failed contractions as a target
        for fc in self.failed_contractions:
            try:
                _, tgt = fc.split(', ')
                if tgt == vertex:
                    # Check if this is the only path to this vertex
                    # If so, the vertex is not reachable
                    all_incoming = self.get_all_incoming_arcs(vertex)
                    if len(all_incoming) == 1 and all_incoming[0] == fc:
                        return False
            except Exception:
                continue
        
        # Check if vertex is reachable through a contracted path
        for path_info in self.contraction_path.values():
            contracted_path = path_info.get('contracted_path', [])
            for arc in contracted_path:
                try:
                    _, target = self.get_arc(arc).split(', ')
                    if target == vertex:
                        return True
                except Exception:
                    continue
        
        # Check all arcs leading to this vertex
        incoming_arcs = []
        for arc in self.R:
            arc_str = self.get_arc(arc)
            try:
                source, target = arc_str.split(', ')
                if target == vertex:
                    incoming_arcs.append((source, arc_str))
            except Exception:
                continue
        
        # If vertex is an AND-join, all incoming arcs with non-epsilon c-attributes 
        # must be reachable
        if vertex in self.join_vertices and self.join_classifications[vertex]['type'] == 'AND-JOIN':
            # Get all non-epsilon incoming arcs
            non_epsilon_arcs = []
            for source, arc_str in incoming_arcs:
                for arc in self.R:
                    if self.get_arc(arc) == arc_str and self.get_c_attribute(arc) != '0':
                        non_epsilon_arcs.append((source, arc_str))
                        break
            
            # Check if any of these arcs are in failed contractions
            for _, arc_str in non_epsilon_arcs:
                if arc_str in self.failed_contractions:
                    return False  # AND-join can't be traversed if any required arc failed
            
            # All source vertices must be reachable
            for source, _ in non_epsilon_arcs:
                if not self.is_vertex_reachable_from_source(source, visited.copy()):
                    return False
            
            # If all sources are reachable, then the AND-join is reachable
            if non_epsilon_arcs:
                return True
        else:
            # For regular vertices or OR/MIX-joins, any incoming arc is sufficient
            for source, arc_str in incoming_arcs:
                # Skip failed contractions
                if arc_str in self.failed_contractions:
                    continue
                
                if self.is_vertex_reachable_from_source(source, visited.copy()):
                    return True
        
        # If we're here, we couldn't find a path to this vertex
        return False

    def get_all_incoming_arcs(self, vertex):
        """
        Get all arcs that lead to the given vertex.
        
        This method scans the RDLT to find all arcs that have the specified vertex as their target.
        
        Parameters:
            vertex (str): The vertex to find incoming arcs for.
            
        Returns:
            list: A list of arc strings representing all arcs leading to the specified vertex.
        """
        incoming = []
        for arc in self.R:
            arc_str = self.get_arc(arc)
            try:
                _, target = arc_str.split(', ')
                if target == vertex:
                    incoming.append(arc_str)
            except Exception:
                continue
        return incoming

    def extract_activity_profiles(self):
        """
        Extract activity profiles for the RDLT.
        
        This method analyzes the RDLT and generates activity profiles for each arc in the RDLT.
        An activity profile represents the step-by-step execution of the RDLT, showing which arcs
        are traversed at each timestep, whether the sink is reached, and any violations that may
        occur during traversal.
        
        The method handles:
        - Mapping arcs to cycles they belong to
        - Processing contraction paths and failed contractions
        - Building unified graph representation for path finding
        - Constructing deterministic cycle traversal patterns
        - Handling unreached violations and terminal nodes
        - Creating activity profiles for each relevant arc
        
        Returns:
            dict: A dictionary mapping arcs to their activity profiles, where each profile contains:
                - 'S': Timestep-to-arcs mapping showing arcs traversed at each step
                - 'deadlock': Boolean indicating if a deadlock was detected
                - 'successful': Boolean indicating if the sink was reached
                - 'sink_timestep': The timestep at which the sink was reached (if successful)
                - 'traversed_arcs': Count of how many times each arc was traversed
                - 'visited_vertices': Set of vertices that were visited during traversal
                - 'violation_cause': Description of violation cause (if applicable)
        """
        self.activity_profiles = {}
        
        # First, build a mapping of which arcs belong to which cycles
        arc_to_cycles = {}
        cycle_to_arcs = {}  # Track which arcs belong to each cycle
        
        for i, cycle_info in enumerate(self.cycle_list):
            # Extract the cycle
            cycle = None
            if isinstance(cycle_info, dict) and 'cycle' in cycle_info:
                cycle = cycle_info['cycle']
            elif isinstance(cycle_info, list):
                cycle = cycle_info
            
            if cycle:
                cycle_to_arcs[i] = []
                for arc in cycle:
                    arc_str = self.get_arc(arc)
                    cycle_to_arcs[i].append(arc_str)
                    if arc_str not in arc_to_cycles:
                        arc_to_cycles[arc_str] = []
                    arc_to_cycles[arc_str].append(i)  # Store cycle index
        
        # Keep track of processed cycles
        processed_cycles = {}
        
        # Group arcs by the cycles they belong to for consistent processing
        grouped_arcs = {}
        
        # Initialize cycle_vertices dictionary for tracking vertices in each cycle
        cycle_vertices = {}
        
        # Collect all arcs from the contraction path (both successful and failed)
        contraction_path_arcs = set()
        for contract_arc, path_info in sorted(self.contraction_path.items(), key=lambda x: str(x[0])):
            contract_arc_str = self.get_arc(contract_arc)
            contraction_path_arcs.add(contract_arc_str)
            
            # Add successful contractions to the set
            for sc in path_info.get('successful_contractions', []):
                contraction_path_arcs.add(self.get_arc(sc))
            
            # Add contracted path arcs to the set
            for cp in path_info.get('contracted_path', []):
                contraction_path_arcs.add(self.get_arc(cp))
        
        # Combine with failed contractions to get the full set of considered arcs
        considered_arcs = contraction_path_arcs.union(self.failed_contractions)
        
        # Check if there are any violating arcs that aren't in the contraction path or failed contractions
        # These would be arcs in violations that were never considered in any contraction
        unreached_violations = []
        for violation in self.violations:
            if isinstance(violation, dict) and 'arc' in violation:
                violation_arc = self.get_arc(violation['arc'])
                if violation_arc not in considered_arcs:
                    unreached_violations.append(violation_arc)
        
        for contract_arc, path_info in sorted(self.contraction_path.items(), key=lambda x: str(x[0])):
            contract_arc_str = self.get_arc(contract_arc)
            
            # Check if this arc is part of a cycle
            if contract_arc_str in arc_to_cycles:
                # Get first cycle this arc belongs to
                cycle_idx = arc_to_cycles[contract_arc_str][0]
                
                # Create group key based on cycle
                group_key = f"cycle_{cycle_idx}"
                
                if group_key not in grouped_arcs:
                    grouped_arcs[group_key] = []
                
                # Add to group
                grouped_arcs[group_key].append((contract_arc, path_info))
            else:
                # Non-cycle arc gets its own group
                grouped_arcs[contract_arc_str] = [(contract_arc, path_info)]
        
        # Build a unified graph representation for path finding
        graph = defaultdict(list)
        for arc in self.R:
            arc_str = self.get_arc(arc)
            try:
                src, tgt = arc_str.split(', ')
                graph[src].append((tgt, arc))
            except Exception:
                continue
        
        # Preprocess all cycles to build consistent traversal patterns
        cycle_patterns = {}
        cycle_vertices = {}
        
        for group_key in list(grouped_arcs.keys()):
            # Check if this is a cycle group
            if group_key.startswith("cycle_"):
                cycle_idx = int(group_key.split("_")[1])
                
                # Get all arcs in this cycle
                cycle_arcs = cycle_to_arcs.get(cycle_idx, [])
                if not cycle_arcs:
                    continue
                
                # Find all vertices in the cycle
                vtx_set = set()
                for arc_str in cycle_arcs:
                    try:
                        src, tgt = arc_str.split(', ')
                        vtx_set.add(src)
                        vtx_set.add(tgt)
                    except Exception:
                        continue
                
                # Skip if no vertices
                if not vtx_set:
                    continue
                
                cycle_vertices[cycle_idx] = vtx_set
                
                # The key is to create a fully ordered, deterministic cycle pattern
                # that includes all necessary arcs in the right sequence
                standard_cycle = []
                
                # Extract vertices from cycle arcs and build adjacency
                cycle_adjacency = defaultdict(list)
                for arc_str in cycle_arcs:
                    try:
                        src, tgt = arc_str.split(', ')
                        if src in vtx_set and tgt in vtx_set:
                            cycle_adjacency[src].append((tgt, arc_str))
                    except Exception:
                        continue
                
                # Ensure deterministic ordering of adjacency lists
                for src in cycle_adjacency:
                    cycle_adjacency[src].sort(key=lambda x: x[0])  # Sort by target vertex
                
                # Choose a deterministic starting vertex
                start_vertices = sorted(vtx_set)
                start_vtx = start_vertices[0]
                
                # Build a path through the cycle
                visited = {start_vtx}
                current = start_vtx
                
                # First, build canonical ordering of vertices
                ordered_vertices = sorted(vtx_set)
                canonical_order = {}
                for i, vtx in enumerate(ordered_vertices):
                    canonical_order[vtx] = i
                
                # Create a fully deterministic cycle by connecting vertices in canonical order
                for i in range(len(ordered_vertices)):
                    current_vtx = ordered_vertices[i]
                    next_vtx = ordered_vertices[(i + 1) % len(ordered_vertices)]
                    
                    # Find a path from current_vtx to next_vtx
                    path = self.find_path_in_adjacency(current_vtx, next_vtx, cycle_adjacency, set())
                    if path:
                        for arc in path:
                            if arc not in standard_cycle:
                                standard_cycle.append(arc)
                    else:
                        # If no direct path, add an arc if there's one in the cycle arcs
                        for arc_str in sorted(cycle_arcs):
                            try:
                                src, tgt = arc_str.split(', ')
                                if src == current_vtx and tgt == next_vtx and arc_str not in standard_cycle:
                                    standard_cycle.append(arc_str)
                                    break
                            except Exception:
                                continue
                
                # Ensure all cycle arcs are included
                for arc_str in sorted(cycle_arcs):
                    if arc_str not in standard_cycle:
                        standard_cycle.append(arc_str)
                
                # Store this cycle pattern
                cycle_patterns[cycle_idx] = standard_cycle
                # print(f"Standard cycle {cycle_idx} pattern: {standard_cycle}")
        
        # Process each group of arcs
        for group_key, arc_group in grouped_arcs.items():
            cycle_idx = None
            
            # Check if this is a cycle group
            if group_key.startswith("cycle_"):
                cycle_idx = int(group_key.split("_")[1])
                
            # Get the canonical example arc for this group
            canonical_arc, canonical_path_info = arc_group[0]
            
            # Precompute l-attributes for all arcs to ensure consistent traversal
            max_l_attribute = 0
            for contract_arc, _ in arc_group:
                arc_str = self.get_arc(contract_arc)
                l_attr = 0
                for arc in self.R:
                    if self.get_arc(arc) == arc_str:
                        l_attr = self.get_l_attribute(arc)
                        break
                max_l_attribute = max(max_l_attribute, l_attr)
            
            # For each arc in the group, create an activity profile based on the same traversal pattern
            for contract_arc, path_info in arc_group:
                # Initialize the profile with a default empty value
                profile = {
                    'S': {},
                    'deadlock': False,
                    'successful': False,
                    'sink_timestep': None,
                    'traversed_arcs': {},
                    'visited_vertices': set(),
                }
                
                # Check if the contract arc is in unreached violations
                contract_arc_str = self.get_arc(contract_arc)
                if contract_arc_str in unreached_violations:
                    # Create a profile that just follows the contracted path from the contraction path
                    # to show a successful path to the sink
                    
                    # Use the contracted path from this path_info
                    contracted_path = path_info.get('contracted_path', [])
                    if contracted_path:
                        # Strictly follow the contraction path step by step
                        # print(f"Following contracted path for unreachable arc {contract_arc_str}")
                        
                        # Start with timestep 1
                        timestep = 1
                        
                        # Process each arc in the contracted path
                        for idx, path_arc in enumerate(contracted_path):
                            path_arc_str = self.get_arc(path_arc)
                            
                            # Add the arc to the profile
                            profile['S'][timestep] = {path_arc_str}
                            profile['traversed_arcs'][path_arc_str] = 1
                            
                            # Update visited vertices
                            try:
                                src, tgt = path_arc_str.split(', ')
                                profile['visited_vertices'].add(src)
                                profile['visited_vertices'].add(tgt)
                                
                                # Check if we've reached the sink
                                if tgt == self.sink:
                                    profile['successful'] = True
                                    profile['sink_timestep'] = timestep
                            except Exception as e:
                                print(f"Error processing contracted path arc {path_arc_str}: {str(e)}")
                            
                            timestep += 1
                        
                        # If we haven't reached the sink and we have arcs, try to find a path to it
                        if not profile['successful'] and profile['S']:
                            # Get the last vertex we reached
                            last_arc = self.get_arc(contracted_path[-1])
                            try:
                                _, last_vertex = last_arc.split(', ')
                                
                                # If the last vertex isn't the sink, find a path to it
                                if last_vertex != self.sink:
                                    remaining_path = self.find_path(last_vertex, self.sink, graph, set())
                                    if remaining_path:
                                        for path_arc in remaining_path:
                                            profile['S'][timestep] = {path_arc}
                                            profile['traversed_arcs'][path_arc] = 1
                                            try:
                                                _, tgt = path_arc.split(', ')
                                                profile['visited_vertices'].add(tgt)
                                                
                                                if tgt == self.sink:
                                                    profile['successful'] = True
                                                    profile['sink_timestep'] = timestep
                                            except Exception:
                                                pass
                                            
                                            timestep += 1
                            except Exception as e:
                                print(f"Error finding path to sink: {str(e)}")
                    else:
                        # If no contracted path found, use a basic source arc
                        profile['S'][1] = {self.get_source_arc()}
                    
                    # Add the note that the violating arc is unreachable - this is the only part we should display
                    try:
                        src, _ = contract_arc_str.split(', ')
                        profile['violation_cause'] = f"Violating arc {contract_arc_str} is unreachable"
                    except Exception:
                        profile['violation_cause'] = f"Violating arc {contract_arc_str} is unreachable"
                    
                    # If the contracted path reached the sink, mark it as successful
                    if self.sink in profile['visited_vertices']:
                        profile['successful'] = True
                        
                    # Store the profile and continue to next arc
                    self.activity_profiles[contract_arc] = profile
                    continue
                
                try:
                    # Reset traversal tracking for each profile
                    self.traversed_arcs = set()
                    self.arc_traversal_count = defaultdict(int)
                    
                    # Get successful contractions for this path
                    successful_contractions = path_info.get('successful_contractions', [])
                    
                    # Find the original arc that matches the contract_arc
                    profile_arc = next(
                        (c for c in successful_contractions 
                         if self.get_arc(c) == self.get_arc(contract_arc)),
                        None
                    )
                    
                    if not profile_arc:
                        contracted_path = path_info.get('contracted_path', [])
                        if contracted_path:
                            profile_arc = contracted_path[0]
                        else:
                            profile_arc = None
                    
                    contract_arc_str = self.get_arc(contract_arc)
                    
                    # Determine if this arc is part of a cycle
                    in_cycle = contract_arc_str in arc_to_cycles
                    cycle_indices = arc_to_cycles.get(contract_arc_str, [])
                    
                    # For cycle arcs, we want to ensure the same traversal pattern
                    if in_cycle and cycle_idx is not None:
                        # Get the pre-built cycle pattern
                        standard_cycle = cycle_patterns.get(cycle_idx, [])
                        
                        # Generate profile using the standard cycle pattern and group's max l-attribute
                        profile = self.extract_profile_with_joins(
                            profile_arc, 
                            force_include=contract_arc,
                            in_cycle=in_cycle,
                            cycle_indices=cycle_indices,
                            arc_to_cycles=arc_to_cycles,
                            standard_cycle=standard_cycle,
                            max_group_l_attribute=max_l_attribute
                        )
                    else:
                        # Normal processing for non-cycle arcs
                        profile = self.extract_profile_with_joins(
                            profile_arc, 
                            force_include=contract_arc,
                            in_cycle=in_cycle,
                            cycle_indices=cycle_indices,
                            arc_to_cycles=arc_to_cycles
                        )
                except Exception as e:
                    print(f"Error processing contract arc {contract_arc}: {str(e)}")
                    # Keep the default profile initialized above
                
                # Now profile is definitely defined
                self.activity_profiles[contract_arc] = profile
        
        # Special handling for unreached violations that weren't part of any group
        for violation_arc in unreached_violations:
            # Check if we already processed this violation arc
            if any(self.get_arc(arc) == violation_arc for arc in self.activity_profiles):
                continue
                
            # Create a dummy contract arc for this violation
            dummy_contract_arc = {'arc': violation_arc}
            
            # Create a profile that follows a successful path from source to sink
            profile = {
                'S': {},
                'deadlock': False,
                'successful': False,
                'sink_timestep': None,
                'traversed_arcs': {},
                'visited_vertices': set(),
            }
            
            # Look for any successful path from any contraction path
            found_successful_path = False
            for _, path_info in self.contraction_path.items():
                contracted_path = path_info.get('contracted_path', [])
                if contracted_path:
                    # Found a contracted path, use it
                    found_successful_path = True
                    # print(f"Following contracted path for standalone unreachable arc {violation_arc}")
                    
                    # Process each arc in the path
                    timestep = 1
                    for path_arc in contracted_path:
                        path_arc_str = self.get_arc(path_arc)
                        
                        # Add arc to profile
                        profile['S'][timestep] = {path_arc_str}
                        profile['traversed_arcs'][path_arc_str] = 1
                        
                        # Update visited vertices
                        try:
                            src, tgt = path_arc_str.split(', ')
                            profile['visited_vertices'].add(src)
                            profile['visited_vertices'].add(tgt)
                            
                            # Check if we've reached the sink
                            if tgt == self.sink:
                                profile['successful'] = True
                                profile['sink_timestep'] = timestep
                        except Exception:
                            pass
                        
                        timestep += 1
                    
                    # If path didn't reach sink, try to find a path to it
                    if not profile['successful'] and contracted_path:
                        last_arc = self.get_arc(contracted_path[-1])
                        try:
                            _, last_vertex = last_arc.split(', ')
                            
                            # If the last vertex isn't the sink, find a path to it
                            if last_vertex != self.sink:
                                remaining_path = self.find_path(last_vertex, self.sink, graph, set())
                                if remaining_path:
                                    for path_arc in remaining_path:
                                        profile['S'][timestep] = {path_arc}
                                        profile['traversed_arcs'][path_arc] = 1
                                        try:
                                            _, tgt = path_arc.split(', ')
                                            profile['visited_vertices'].add(tgt)
                                            
                                            if tgt == self.sink:
                                                profile['successful'] = True
                                                profile['sink_timestep'] = timestep
                                        except Exception:
                                            pass
                                        
                                        timestep += 1
                        except Exception:
                            pass
                    
                    # We found and processed a path, no need to check others
                    break
            
            # If we didn't find any successful contraction path, try a direct path from source to sink
            if not found_successful_path:
                # Find a simple path from source to sink
                simple_path = self.find_path(self.source, self.sink, graph, set())
                if simple_path:
                    timestep = 1
                    for path_arc in simple_path:
                        profile['S'][timestep] = {path_arc}
                        profile['traversed_arcs'][path_arc] = 1
                        try:
                            _, tgt = path_arc.split(', ')
                            profile['visited_vertices'].add(tgt)
                            
                            if tgt == self.sink:
                                profile['successful'] = True
                                profile['sink_timestep'] = timestep
                        except Exception:
                            pass
                        
                        timestep += 1
                else:
                    # If no path found, just add a placeholder
                    profile['S'][1] = {self.get_source_arc()}
            
            # Add note about unreachable violating arc
            try:
                src, _ = violation_arc.split(', ')
                profile['violation_cause'] = f"Violating arc {violation_arc} is unreachable from source to sink path"
            except Exception:
                profile['violation_cause'] = f"Violating arc {violation_arc} is unreachable"
            
            # Store the profile
            self.activity_profiles[dummy_contract_arc] = profile
        
        return self.activity_profiles

    def extract_profile_with_joins(self, contract_arc=None, force_include=None, in_cycle=False, 
                                   cycle_indices=None, arc_to_cycles=None, standard_cycle=None,
                                   max_group_l_attribute=None):
        """
        Extract an activity profile for a specific arc, handling join vertices and cycles.
        
        This method generates a detailed activity profile that simulates the execution of the RDLT
        when focusing on a specific arc, particularly dealing with complex structures like joins and cycles.
        
        Parameters:
            contract_arc (dict/str, optional): The arc to focus on. Defaults to None.
            force_include (dict/str, optional): Arc that must be included in the profile. Defaults to None.
            in_cycle (bool, optional): Whether the arc is part of a cycle. Defaults to False.
            cycle_indices (list, optional): Indices of cycles the arc belongs to. Defaults to None.
            arc_to_cycles (dict, optional): Mapping of arcs to their containing cycles. Defaults to None.
            standard_cycle (list, optional): A predefined cycle pattern to use. Defaults to None.
            max_group_l_attribute (int, optional): Maximum L-attribute for a group of related arcs. Defaults to None.
            
        Returns:
            dict: An activity profile containing execution details such as:
                - 'S': Dictionary mapping timesteps to sets of traversed arcs
                - 'deadlock': Boolean indicating if execution reached a deadlock
                - 'successful': Boolean indicating if the sink was reached
                - 'sink_timestep': Timestep at which the sink was reached (if successful)
                - 'traversed_arcs': Count of how many times each arc was traversed
                - 'visited_vertices': Set of vertices visited during execution
                - 'violation_cause': Description of any violation that occurred
        """
        activity_profile = {
            'S': defaultdict(set),
            'deadlock': False,
            'successful': False,
            'sink_timestep': None,
            'traversed_arcs': defaultdict(int),
            'visited_vertices': set(),
            'required_arcs': set(),
            'vertex_paths': {},
            'violation_cause': None
        }

        # Always add source to visited vertices
        activity_profile['visited_vertices'].add(self.source)
        
        # Determine contract arc details
        contract_arc_str = None
        target_l_attribute = 0
        
        if force_include:
            contract_arc_str = self.get_arc(force_include)
            # Get l-attribute for the contract arc
            for arc in self.R:
                if self.get_arc(arc) == contract_arc_str:
                    target_l_attribute = self.get_l_attribute(arc)
                    break

        # Build a graph representation for path finding
        graph = defaultdict(list)
        for arc in self.R:
            arc_str = self.get_arc(arc)
            try:
                src, tgt = arc_str.split(', ')
                graph[src].append((tgt, arc))
            except Exception:
                continue
        
        # Ensure deterministic ordering of the graph adjacency lists
        for src in graph:
            graph[src].sort(key=lambda x: x[0])  # Sort by target vertex
        
        # Check for self-loop
        is_self_loop = False
        if in_cycle and contract_arc_str:
            try:
                src, tgt = contract_arc_str.split(', ')
                if src == tgt:
                    is_self_loop = True
            except Exception:
                pass

        # Start from source vertex
        current_vertex = self.source
        timestep = 1
        
        # For non-cycle arcs, find shortest path from source to sink through contract arc
        if not in_cycle and contract_arc_str:
            # Get source and target of contract arc
            contract_src, contract_tgt = contract_arc_str.split(', ')
            
            # First check if the contract source and target are reachable
            if not self.is_vertex_reachable_from_source(contract_src):
                # Can't reach the contract source
                activity_profile['violation_cause'] = f"Contract source {contract_src} is unreachable"
                
                # Find a direct path from source to sink instead
                direct_path = self.find_path(self.source, self.sink, graph, set())
                
                if direct_path:
                    # Show only the path that leads directly to the sink
                    activity_profile['note'] = f"Activity excludes violating arc due to unreachability"
                    
                    # Reset the profile to start from source
                    activity_profile['S'] = {}
                    activity_profile['traversed_arcs'] = {}
                    activity_profile['visited_vertices'] = {self.source}
                    
                    for i, arc in enumerate(direct_path):
                        # Add step to activity profile
                        ts = i + 1  # timestep starts at 1
                        activity_profile['S'][ts] = {arc}
                        activity_profile['traversed_arcs'][arc] = 1
                        
                        # Mark destination as visited
                        try:
                            _, tgt = arc.split(', ')
                            activity_profile['visited_vertices'].add(tgt)
                            
                            # If we reached the sink, mark as successful
                            if tgt == self.sink:
                                activity_profile['successful'] = True
                                activity_profile['sink_timestep'] = ts
                        except Exception:
                            pass
                else:
                    # No path to sink, just show starting from source
                    source_arc = self.get_source_arc()
                    activity_profile['S'][1] = {source_arc}
                
                # Clean up profile and return
                activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
                return activity_profile
            
            # Check if the contract arc directly goes to a terminal node (not the sink)
            outgoing_arcs = []
            for arc in self.R:
                arc_str = self.get_arc(arc)
                try:
                    src, _ = arc_str.split(', ')
                    if src == contract_tgt:
                        outgoing_arcs.append(arc_str)
                except Exception:
                    continue
            
            # If target has no outgoing arcs and is not the sink, it's a terminal node
            is_terminal = len(outgoing_arcs) == 0 and contract_tgt != self.sink
            
            # Find path from source to contract src (if not already at source)
            if contract_src != self.source:
                path_to_contract = self.find_path(self.source, contract_src, graph, set())
                
                if path_to_contract:
                    # Add path to profile
                    for path_arc in path_to_contract:
                        # Define direct arc addition function for inline use
                        try:
                            p_src, p_tgt = path_arc.split(', ')
                            
                            # Check L-attribute limit
                            arc_l_attribute = 0
                            for arc in self.R:
                                if self.get_arc(arc) == path_arc:
                                    arc_l_attribute = self.get_l_attribute(arc)
                                    break
                            
                            current_traversal_count = activity_profile['traversed_arcs'].get(path_arc, 0)
                            if current_traversal_count >= arc_l_attribute:
                                # L-attribute limit reached, mark deadlock
                                activity_profile['deadlock'] = True
                                activity_profile['violation_cause'] = f"Arc {path_arc} has reached its L-attribute limit of {arc_l_attribute}"
                                break
                            
                            # Handle AND-joins
                            if p_tgt in self.join_vertices and self.join_classifications[p_tgt]['type'] == 'AND-JOIN':
                                # Check if all sources are reachable
                                unreachable_sources = []
                                non_epsilon_sources = []
                                
                                for a in self.R:
                                    a_str = self.get_arc(a)
                                    try:
                                        a_src, a_tgt = a_str.split(', ')
                                        if a_tgt == p_tgt and self.get_c_attribute(a) != '0':
                                            non_epsilon_sources.append(a_src)
                                            if a_src not in activity_profile['visited_vertices'] and a_src != current_vertex and not self.is_vertex_reachable_from_source(a_src):
                                                unreachable_sources.append(a_src)
                                    except Exception:
                                        continue
                                
                                if unreachable_sources:
                                    # Can't proceed due to unreachable sources
                                    activity_profile['deadlock'] = True
                                    activity_profile['violation_cause'] = f"Deadlock at AND-join {p_tgt}: unreachable sources {unreachable_sources}"
                                    break
                                
                                # Check if all required sources are available
                                if all(s in activity_profile['visited_vertices'] or s == current_vertex for s in non_epsilon_sources):
                                    # Add all join arcs
                                    for a in self.R:
                                        a_str = self.get_arc(a)
                                        try:
                                            a_src, a_tgt = a_str.split(', ')
                                            if a_tgt == p_tgt and self.get_c_attribute(a) != '0':
                                                # Check L-attribute limit for join arc
                                                a_l_attribute = self.get_l_attribute(a)
                                                a_count = activity_profile['traversed_arcs'].get(a_str, 0)
                                                if a_count < a_l_attribute:
                                                    activity_profile['S'][timestep].add(a_str)
                                                    activity_profile['traversed_arcs'][a_str] += 1
                                        except Exception:
                                            continue
                                    
                                    activity_profile['visited_vertices'].add(p_tgt)
                                    current_vertex = p_tgt
                                else:
                                    # Not all sources visited yet
                                    break
                            else:
                                # Regular arc
                                activity_profile['S'][timestep].add(path_arc)
                                activity_profile['traversed_arcs'][path_arc] += 1
                                activity_profile['visited_vertices'].add(p_tgt)
                                current_vertex = p_tgt
                        except Exception as e:
                            print(f"Error processing arc {path_arc}: {str(e)}")
                            break
                        
                        timestep += 1
            
            # Add the contract arc
            if current_vertex == contract_src:
                # Skip the contract arc if it's a failed contraction
                if contract_arc_str in self.failed_contractions:
                    # Check if we already have a starting point
                    if len(activity_profile['S']) == 0:
                        source_arc = self.get_source_arc()
                        activity_profile['S'][1].add(source_arc)  # Add source arc if profile is empty
                    activity_profile['deadlock'] = True
                    activity_profile['violation_cause'] = f"Contract arc {contract_arc_str} is in failed contractions"
                    
                    # Clean up profile and return
                    activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
                    return activity_profile
                
                # Check if the contract target is an AND-join with unreachable sources
                if contract_tgt in self.join_vertices and self.join_classifications[contract_tgt]['type'] == 'AND-JOIN':
                    unreachable_sources = []
                    
                    for a in self.R:
                        a_str = self.get_arc(a)
                        try:
                            a_src, a_tgt = a_str.split(', ')
                            if a_tgt == contract_tgt and self.get_c_attribute(a) != '0' and a_src != contract_src:
                                if not self.is_vertex_reachable_from_source(a_src):
                                    unreachable_sources.append(a_src)
                        except Exception:
                            continue
                    
                    if unreachable_sources:
                        # Show the first step but then deadlock
                        activity_profile['S'][timestep].add(contract_arc_str)
                        activity_profile['traversed_arcs'][contract_arc_str] += 1
                        activity_profile['visited_vertices'].add(contract_tgt)
                        
                        # Mark as deadlock
                        activity_profile['deadlock'] = True
                        activity_profile['violation_cause'] = f"Deadlock at AND-join {contract_tgt}: unreachable sources {unreachable_sources}"
                        
                        # Clean up profile and return
                        activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
                        return activity_profile
                
                # Add the contract arc to the profile
                activity_profile['S'][timestep].add(contract_arc_str)
                activity_profile['traversed_arcs'][contract_arc_str] += 1
                activity_profile['visited_vertices'].add(contract_tgt)
                current_vertex = contract_tgt
                timestep += 1
                
                # If this is a terminal node (not the sink), end traversal here
                if is_terminal:
                    # Include the contract arc in the profile first - but check if it has already been traversed
                    if contract_arc_str not in activity_profile['traversed_arcs']:
                        activity_profile['S'][timestep] = {contract_arc_str}
                        activity_profile['traversed_arcs'][contract_arc_str] = 1
                        activity_profile['visited_vertices'].add(contract_tgt)
                        timestep += 1
                    
                    # Mark it as terminal node for reporting
                    activity_profile['violation_cause'] = f"Terminal node {contract_tgt} reached, no path to sink"
                    
                    # Instead of returning immediately, find an alternative path to sink from source
                    # But start from the source, not the terminal node
                    direct_path_to_sink = self.find_path(self.source, self.sink, graph, set())
                    if direct_path_to_sink:
                        # The following flag tracks if we've used an entirely new path to the sink
                        used_new_path = False
                        alt_timestep = timestep
                        
                        # Add each arc in the path if not already traversed
                        for path_arc in direct_path_to_sink:
                            # Skip arcs we've already traversed, unless we're specifically showing the alt path
                            if path_arc in activity_profile['traversed_arcs'] and not used_new_path:
                                continue
                                
                            # Once we start a new path, we should follow it completely
                            used_new_path = True
                            
                            activity_profile['S'][alt_timestep] = {path_arc}
                            activity_profile['traversed_arcs'][path_arc] = 1
                            try:
                                _, tgt = path_arc.split(', ')
                                activity_profile['visited_vertices'].add(tgt)
                                
                                if tgt == self.sink:
                                    activity_profile['successful'] = True
                                    activity_profile['sink_timestep'] = alt_timestep
                            except Exception:
                                pass
                            
                            alt_timestep += 1
                        
                        # Clean up profile and return
                        activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
                        return activity_profile
                    
                    # If no alternative path found, just show the terminal arc
                    activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
                    return activity_profile
            
            # Find path from contract target to sink
            path_to_sink = self.find_path(current_vertex, self.sink, graph, set())
            
            if path_to_sink:
                for path_arc in path_to_sink:
                    # Direct arc addition - inline implementation
                    try:
                        p_src, p_tgt = path_arc.split(', ')
                        
                        # Check L-attribute limit
                        arc_l_attribute = 0
                        for arc in self.R:
                            if self.get_arc(arc) == path_arc:
                                arc_l_attribute = self.get_l_attribute(arc)
                                break
                        
                        current_traversal_count = activity_profile['traversed_arcs'].get(path_arc, 0)
                        if current_traversal_count >= arc_l_attribute:
                            # L-attribute limit reached, mark deadlock
                            activity_profile['deadlock'] = True
                            activity_profile['violation_cause'] = f"Arc {path_arc} has reached its L-attribute limit of {arc_l_attribute}"
                            break
                        
                        # Handle AND-joins
                        if p_tgt in self.join_vertices and self.join_classifications[p_tgt]['type'] == 'AND-JOIN':
                            # Check if all sources are reachable
                            unreachable_sources = []
                            non_epsilon_sources = []
                            
                            for a in self.R:
                                a_str = self.get_arc(a)
                                try:
                                    a_src, a_tgt = a_str.split(', ')
                                    if a_tgt == p_tgt and self.get_c_attribute(a) != '0':
                                        non_epsilon_sources.append(a_src)
                                        if a_src not in activity_profile['visited_vertices'] and a_src != current_vertex and not self.is_vertex_reachable_from_source(a_src):
                                            unreachable_sources.append(a_src)
                                except Exception:
                                    continue
                            
                            if unreachable_sources:
                                # Can't proceed due to unreachable sources
                                activity_profile['deadlock'] = True
                                activity_profile['violation_cause'] = f"Deadlock at AND-join {p_tgt}: unreachable sources {unreachable_sources}"
                                break
                            
                            # Check if all required sources are available
                            if all(s in activity_profile['visited_vertices'] or s == current_vertex for s in non_epsilon_sources):
                                # Add all join arcs
                                for a in self.R:
                                    a_str = self.get_arc(a)
                                    try:
                                        a_src, a_tgt = a_str.split(', ')
                                        if a_tgt == p_tgt and self.get_c_attribute(a) != '0':
                                            # Check L-attribute limit for join arc
                                            a_l_attribute = self.get_l_attribute(a)
                                            a_count = activity_profile['traversed_arcs'].get(a_str, 0)
                                            if a_count < a_l_attribute:
                                                activity_profile['S'][timestep].add(a_str)
                                                activity_profile['traversed_arcs'][a_str] += 1
                                    except Exception:
                                        continue
                                
                                activity_profile['visited_vertices'].add(p_tgt)
                                current_vertex = p_tgt
                            else:
                                # Not all sources visited yet
                                break
                        else:
                            # Regular arc
                            activity_profile['S'][timestep].add(path_arc)
                            activity_profile['traversed_arcs'][path_arc] += 1
                            activity_profile['visited_vertices'].add(p_tgt)
                            current_vertex = p_tgt
                    except Exception as e:
                        print(f"Error processing arc {path_arc}: {str(e)}")
                        break
                    
                    timestep += 1
            
            # Mark as successful
            if current_vertex == self.sink:
                activity_profile['successful'] = True
                activity_profile['sink_timestep'] = timestep - 1
            
            # Clean up profile and return
            activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
            return activity_profile
        
        # Handle self-loops specially
        if is_self_loop:
            # First add path to self-loop if not starting at its source
            self_loop_src, _ = contract_arc_str.split(', ')
            
            if current_vertex != self_loop_src:
                path_to_loop = self.find_path(current_vertex, self_loop_src, graph, set())
                
                if path_to_loop:
                    for path_arc in path_to_loop:
                        # Direct arc addition - inline implementation
                        try:
                            p_src, p_tgt = path_arc.split(', ')
                            
                            # Check L-attribute limit
                            arc_l_attribute = 0
                            for arc in self.R:
                                if self.get_arc(arc) == path_arc:
                                    arc_l_attribute = self.get_l_attribute(arc)
                                    break
                            
                            current_traversal_count = activity_profile['traversed_arcs'].get(path_arc, 0)
                            if current_traversal_count >= arc_l_attribute:
                                # L-attribute limit reached, mark deadlock
                                activity_profile['deadlock'] = True
                                activity_profile['violation_cause'] = f"Arc {path_arc} has reached its L-attribute limit of {arc_l_attribute}"
                                break
                            
                            # Handle AND-joins
                            if p_tgt in self.join_vertices and self.join_classifications[p_tgt]['type'] == 'AND-JOIN':
                                # Check if all sources are reachable
                                unreachable_sources = []
                                non_epsilon_sources = []
                                
                                for a in self.R:
                                    a_str = self.get_arc(a)
                                    try:
                                        a_src, a_tgt = a_str.split(', ')
                                        if a_tgt == p_tgt and self.get_c_attribute(a) != '0':
                                            non_epsilon_sources.append(a_src)
                                            if a_src not in activity_profile['visited_vertices'] and a_src != current_vertex and not self.is_vertex_reachable_from_source(a_src):
                                                unreachable_sources.append(a_src)
                                    except Exception:
                                        continue
                                
                                if unreachable_sources:
                                    # Can't proceed due to unreachable sources
                                    activity_profile['deadlock'] = True
                                    activity_profile['violation_cause'] = f"Deadlock at AND-join {p_tgt}: unreachable sources {unreachable_sources}"
                                    break
                                
                                # Check if all required sources are available
                                if all(s in activity_profile['visited_vertices'] or s == current_vertex for s in non_epsilon_sources):
                                    # Add all join arcs
                                    for a in self.R:
                                        a_str = self.get_arc(a)
                                        try:
                                            a_src, a_tgt = a_str.split(', ')
                                            if a_tgt == p_tgt and self.get_c_attribute(a) != '0':
                                                # Check L-attribute limit for join arc
                                                a_l_attribute = self.get_l_attribute(a)
                                                a_count = activity_profile['traversed_arcs'].get(a_str, 0)
                                                if a_count < a_l_attribute:
                                                    activity_profile['S'][timestep].add(a_str)
                                                    activity_profile['traversed_arcs'][a_str] += 1
                                        except Exception:
                                            continue
                                    
                                    activity_profile['visited_vertices'].add(p_tgt)
                                    current_vertex = p_tgt
                            else:
                                # Regular arc
                                activity_profile['S'][timestep].add(path_arc)
                                activity_profile['traversed_arcs'][path_arc] += 1
                                activity_profile['visited_vertices'].add(p_tgt)
                                current_vertex = p_tgt
                        except Exception as e:
                            print(f"Error processing arc {path_arc}: {str(e)}")
                            break
                        
                        timestep += 1
            
            # Skip the self-loop if it's a failed contraction
            if contract_arc_str in self.failed_contractions:
                # Check if we already have a starting point
                if len(activity_profile['S']) == 0:
                    source_arc = self.get_source_arc()
                    activity_profile['S'][1].add(source_arc)  # Add source arc if profile is empty
                activity_profile['deadlock'] = True
                activity_profile['violation_cause'] = f"Self-loop arc {contract_arc_str} is in failed contractions"
                
                # Clean up profile and return
                activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
                return activity_profile
                
            # Even if the self-loop arc is in failed contractions, we should try to traverse it
            # for the purpose of the activity profile
            traversal_count = 0
            while traversal_count < target_l_attribute:
                # Check if we've already reached the L-attribute limit for this arc
                current_count = activity_profile['traversed_arcs'].get(contract_arc_str, 0)
                if current_count >= target_l_attribute:
                    break
                
                activity_profile['S'][timestep].add(contract_arc_str)
                activity_profile['traversed_arcs'][contract_arc_str] += 1
                traversal_count += 1
                timestep += 1
            
            # Find path to sink
            path_to_sink = self.find_path(self_loop_src, self.sink, graph, set())
            
            if path_to_sink:
                for path_arc in path_to_sink:
                    # Inline the add_arc_to_profile functionality
                    try:
                        src, tgt = path_arc.split(', ')
                        
                        # Check if we've already reached the L-attribute limit for this arc
                        arc_l_attribute = 0
                        for arc in self.R:
                            if self.get_arc(arc) == path_arc:
                                arc_l_attribute = self.get_l_attribute(arc)
                                break
                        
                        current_traversal_count = activity_profile['traversed_arcs'].get(path_arc, 0)
                        if current_traversal_count >= arc_l_attribute:
                            # We've reached the L-attribute limit, can't traverse this arc anymore
                            activity_profile['deadlock'] = True
                            activity_profile['violation_cause'] = f"Arc {path_arc} has reached its L-attribute limit of {arc_l_attribute}"
                            continue
                        
                        # Check for joins
                        if tgt in self.join_vertices and self.join_classifications[tgt]['type'] == 'AND-JOIN':
                            # For AND-JOIN, check if all incoming sources are reachable
                            unreachable_sources = []
                            
                            # Find all incoming arcs with non-epsilon c-attributes
                            non_epsilon_sources = []
                            for a in self.R:
                                a_str = self.get_arc(a)
                                try:
                                    a_src, a_tgt = a_str.split(', ')
                                    if a_tgt == tgt and self.get_c_attribute(a) != '0':
                                        non_epsilon_sources.append(a_src)
                                        # Check if this source is reachable from the starting point
                                        if a_src not in activity_profile['visited_vertices'] and not self.is_vertex_reachable_from_source(a_src):
                                            unreachable_sources.append(a_src)
                                except Exception:
                                    continue
                            
                            # If any source is unreachable, mark as deadlock
                            if unreachable_sources:
                                activity_profile['deadlock'] = True
                                activity_profile['violation_cause'] = f"Deadlock at AND-join {tgt}: unreachable sources {unreachable_sources}"
                                continue
                            
                            # If all sources are either visited or reachable, proceed with the join
                            if all(s in activity_profile['visited_vertices'] or s == current_vertex for s in non_epsilon_sources):
                                # Add all join arcs to the same timestep
                                for a in self.R:
                                    a_str = self.get_arc(a)
                                    try:
                                        a_src, a_tgt = a_str.split(', ')
                                        if a_tgt == tgt and self.get_c_attribute(a) != '0':
                                            # Check L-attribute limit for each join arc
                                            a_l_attribute = self.get_l_attribute(a)
                                            a_traversal_count = activity_profile['traversed_arcs'].get(a_str, 0)
                                            if a_traversal_count < a_l_attribute:
                                                activity_profile['S'][timestep].add(a_str)
                                                activity_profile['traversed_arcs'][a_str] += 1
                                    except Exception:
                                        continue
                                
                                activity_profile['visited_vertices'].add(tgt)
                                current_vertex = tgt
                            else:
                                # Can't traverse yet - not all sources have been visited
                                continue
                        else:
                            # Regular arc
                            activity_profile['S'][timestep].add(path_arc)
                            activity_profile['traversed_arcs'][path_arc] += 1
                            activity_profile['visited_vertices'].add(tgt)
                            current_vertex = tgt
                    except Exception as e:
                        print(f"Error processing arc {path_arc}: {str(e)}")
                        continue
                    
                    timestep += 1
            
            # Mark as successful
            if current_vertex == self.sink:
                activity_profile['successful'] = True
                activity_profile['sink_timestep'] = timestep - 1
            
            # Clean up profile and return
            activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
            return activity_profile
        
        # For regular cycles, use the provided standard cycle if available
        if in_cycle and not is_self_loop:
            # Extract cycle vertices from standard cycle
            cycle_vertices = set()
            
            # If we have a standard cycle pattern, use it
            if standard_cycle:
                for arc_str in standard_cycle:
                    try:
                        src, tgt = arc_str.split(', ')
                        cycle_vertices.add(src)
                        cycle_vertices.add(tgt)
                    except Exception:
                        continue
            else:
                # If no standard cycle provided, extract from the cycle indices
                cycle_arcs = []
                
                if cycle_indices:
                    for cycle_idx in cycle_indices:
                        cycle_info = self.cycle_list[cycle_idx]
                        cycle = None
                        if isinstance(cycle_info, dict) and 'cycle' in cycle_info:
                            cycle = cycle_info['cycle']
                        elif isinstance(cycle_info, list):
                            cycle = cycle_info
                        
                        if cycle:
                            for arc in cycle:
                                arc_str = self.get_arc(arc)
                                try:
                                    src, tgt = arc_str.split(', ')
                                    cycle_vertices.add(src)
                                    cycle_vertices.add(tgt)
                                    cycle_arcs.append(arc_str)
                                except Exception:
                                    continue
                
                # No standard cycle, build one now
                if not standard_cycle:
                    # Try to find the simplest cycle that includes our arc
                    standard_cycle = []
                    
                    if contract_arc_str and contract_arc_str in cycle_arcs:
                        try:
                            src, tgt = contract_arc_str.split(', ')
                            
                            # Start with our contract arc
                            standard_cycle.append(contract_arc_str)
                            
                            # Find path back to complete the cycle
                            cycle_path = self.find_path(tgt, src, graph, {tgt})
                            if cycle_path:
                                standard_cycle.extend(cycle_path)
                            else:
                                # If no path found, just use all arcs in cycle
                                standard_cycle = cycle_arcs
                        except Exception:
                            standard_cycle = cycle_arcs
                    else:
                        standard_cycle = cycle_arcs
            
            # Get to the cycle from source
            if self.source not in cycle_vertices and current_vertex == self.source:
                # First, check if any cycle vertex is reachable
                reachable_cycle_vertices = [v for v in cycle_vertices if self.is_vertex_reachable_from_source(v)]
                
                if not reachable_cycle_vertices:
                    # No cycle vertices are reachable
                    activity_profile['deadlock'] = True
                    activity_profile['violation_cause'] = f"No cycle vertices are reachable from source"
                    activity_profile['S'][1].add(self.get_source_arc())  # Always show we started from source
                    
                    # Clean up profile and return
                    activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
                    return activity_profile
                
                # Find first vertex in the standard cycle
                try:
                    # Try to find a reachable vertex first
                    first_arc = None
                    first_src = None
                    
                    for arc in standard_cycle:
                        arc_src, _ = arc.split(', ')
                        if arc_src in reachable_cycle_vertices:
                            first_arc = arc
                            first_src = arc_src
                            break
                    
                    if not first_src:
                        first_arc = standard_cycle[0]
                        first_src, _ = first_arc.split(', ')
                    
                    # Find path to this vertex
                    path_to_cycle = self.find_path(current_vertex, first_src, graph, set())
                    
                    if path_to_cycle:
                        for path_arc in path_to_cycle:
                            # Direct arc addition - inline implementation
                            try:
                                p_src, p_tgt = path_arc.split(', ')
                                
                                # Check L-attribute limit
                                arc_l_attribute = 0
                                for arc in self.R:
                                    if self.get_arc(arc) == path_arc:
                                        arc_l_attribute = self.get_l_attribute(arc)
                                        break
                                
                                current_traversal_count = activity_profile['traversed_arcs'].get(path_arc, 0)
                                if current_traversal_count >= arc_l_attribute:
                                    # L-attribute limit reached, mark deadlock
                                    activity_profile['deadlock'] = True
                                    activity_profile['violation_cause'] = f"Arc {path_arc} has reached its L-attribute limit of {arc_l_attribute}"
                                    break
                                
                                # Handle AND-joins
                                if p_tgt in self.join_vertices and self.join_classifications[p_tgt]['type'] == 'AND-JOIN':
                                    # Check if all sources are reachable
                                    unreachable_sources = []
                                    non_epsilon_sources = []
                                    
                                    for a in self.R:
                                        a_str = self.get_arc(a)
                                        try:
                                            a_src, a_tgt = a_str.split(', ')
                                            if a_tgt == p_tgt and self.get_c_attribute(a) != '0':
                                                non_epsilon_sources.append(a_src)
                                                if a_src not in activity_profile['visited_vertices'] and a_src != current_vertex and not self.is_vertex_reachable_from_source(a_src):
                                                    unreachable_sources.append(a_src)
                                        except Exception:
                                            continue
                                    
                                    if unreachable_sources:
                                        # Can't proceed due to unreachable sources
                                        activity_profile['deadlock'] = True
                                        activity_profile['violation_cause'] = f"Deadlock at AND-join {p_tgt}: unreachable sources {unreachable_sources}"
                                        break
                                    
                                    # Check if all required sources are available
                                    if all(s in activity_profile['visited_vertices'] or s == current_vertex for s in non_epsilon_sources):
                                        # Add all join arcs
                                        for a in self.R:
                                            a_str = self.get_arc(a)
                                            try:
                                                a_src, a_tgt = a_str.split(', ')
                                                if a_tgt == p_tgt and self.get_c_attribute(a) != '0':
                                                    # Check L-attribute limit for join arc
                                                    a_l_attribute = self.get_l_attribute(a)
                                                    a_count = activity_profile['traversed_arcs'].get(a_str, 0)
                                                    if a_count < a_l_attribute:
                                                        activity_profile['S'][timestep].add(a_str)
                                                        activity_profile['traversed_arcs'][a_str] += 1
                                            except Exception:
                                                continue
                                        
                                        activity_profile['visited_vertices'].add(p_tgt)
                                        current_cycle_vertex = p_tgt
                                    else:
                                        # Not all sources visited yet
                                        break
                                else:
                                    # Regular arc
                                    activity_profile['S'][timestep].add(path_arc)
                                    activity_profile['traversed_arcs'][path_arc] += 1
                                    activity_profile['visited_vertices'].add(p_tgt)
                                    current_cycle_vertex = p_tgt
                            except Exception as e:
                                print(f"Error processing arc {path_arc}: {str(e)}")
                                break
                            
                            timestep += 1
                except Exception:
                    # If can't find first vertex, try any vertex in cycle
                    for vtx in cycle_vertices:
                        path = self.find_path(current_vertex, vtx, graph, set())
                        if path:
                            for path_arc in path:
                                # Direct arc addition - inline implementation
                                try:
                                    p_src, p_tgt = path_arc.split(', ')
                                    
                                    # Check L-attribute limit
                                    arc_l_attribute = 0
                                    for arc in self.R:
                                        if self.get_arc(arc) == path_arc:
                                            arc_l_attribute = self.get_l_attribute(arc)
                                            break
                                    
                                    current_traversal_count = activity_profile['traversed_arcs'].get(path_arc, 0)
                                    if current_traversal_count >= arc_l_attribute:
                                        # L-attribute limit reached, mark deadlock
                                        activity_profile['deadlock'] = True
                                        activity_profile['violation_cause'] = f"Arc {path_arc} has reached its L-attribute limit of {arc_l_attribute}"
                                        break
                                    
                                    # Handle AND-joins
                                    if p_tgt in self.join_vertices and self.join_classifications[p_tgt]['type'] == 'AND-JOIN':
                                        # Check if all sources are reachable
                                        unreachable_sources = []
                                        non_epsilon_sources = []
                                        
                                        for a in self.R:
                                            a_str = self.get_arc(a)
                                            try:
                                                a_src, a_tgt = a_str.split(', ')
                                                if a_tgt == p_tgt and self.get_c_attribute(a) != '0':
                                                    non_epsilon_sources.append(a_src)
                                                    if a_src not in activity_profile['visited_vertices'] and a_src != current_vertex and not self.is_vertex_reachable_from_source(a_src):
                                                        unreachable_sources.append(a_src)
                                            except Exception:
                                                continue
                                        
                                        if unreachable_sources:
                                            # Can't proceed due to unreachable sources
                                            activity_profile['deadlock'] = True
                                            activity_profile['violation_cause'] = f"Deadlock at AND-join {p_tgt}: unreachable sources {unreachable_sources}"
                                            break
                                        
                                        # Check if all required sources are available
                                        if all(s in activity_profile['visited_vertices'] or s == current_vertex for s in non_epsilon_sources):
                                            # Add all join arcs
                                            for a in self.R:
                                                a_str = self.get_arc(a)
                                                try:
                                                    a_src, a_tgt = a_str.split(', ')
                                                    if a_tgt == p_tgt and self.get_c_attribute(a) != '0':
                                                        # Check L-attribute limit for join arc
                                                        a_l_attribute = self.get_l_attribute(a)
                                                        a_count = activity_profile['traversed_arcs'].get(a_str, 0)
                                                        if a_count < a_l_attribute:
                                                            activity_profile['S'][timestep].add(a_str)
                                                            activity_profile['traversed_arcs'][a_str] += 1
                                                except Exception:
                                                    continue
                                            
                                            activity_profile['visited_vertices'].add(p_tgt)
                                            current_cycle_vertex = p_tgt
                                        else:
                                            # Not all sources visited yet
                                            break
                                    else:
                                        # Regular arc
                                        activity_profile['S'][timestep].add(path_arc)
                                        activity_profile['traversed_arcs'][path_arc] += 1
                                        activity_profile['visited_vertices'].add(p_tgt)
                                        current_cycle_vertex = p_tgt
                                except Exception as e:
                                    print(f"Error processing arc {path_arc}: {str(e)}")
                                    break
                                
                                timestep += 1
                            break
            
            # Important: After traversing the contract arc, prioritize following outgoing arcs naturally
            # rather than immediately following a cycle
            if contract_arc_str:
                try:
                    # Get the target of the contract arc
                    _, contract_tgt = contract_arc_str.split(', ')
                    
                    # Find outgoing arcs from this target
                    outgoing_arcs = []
                    for arc in self.R:
                        arc_str = self.get_arc(arc)
                        try:
                            src, _ = arc_str.split(', ')
                            if src == contract_tgt:
                                outgoing_arcs.append(arc_str)
                        except Exception:
                            continue
                    
                    # If there are outgoing arcs, prioritize natural flow over cycle traversal
                    # but ONLY if we've exhausted the contract arc's l-attribute or if
                    # this is not a cycle arc (which we want to prioritize normally)
                    if outgoing_arcs and current_vertex == contract_tgt:
                        # Check if the contract arc has been fully traversed
                        contract_arc_fully_traversed = False
                        current_count = activity_profile['traversed_arcs'].get(contract_arc_str, 0)
                        
                        if current_count >= target_l_attribute:
                            contract_arc_fully_traversed = True
                            # print(f"Contract arc {contract_arc_str} has been fully traversed ({current_count}/{target_l_attribute})")
                        
                        # Only prioritize outgoing arcs if fully traversed or not in cycle
                        if contract_arc_fully_traversed or not in_cycle:
                            # Sort outgoing arcs for deterministic order
                            outgoing_arcs.sort()
                            
                            # Find a path that leads to sink
                            for out_arc in outgoing_arcs:
                                try:
                                    out_src, out_tgt = out_arc.split(', ')
                                    
                                    # Skip cycle arcs that point back to already visited vertices
                                    if out_tgt in activity_profile['visited_vertices'] and out_tgt != self.sink:
                                        continue
                                    
                                    # Skip arcs that have reached L-attribute limit
                                    arc_l_attribute = 0
                                    for arc in self.R:
                                        if self.get_arc(arc) == out_arc:
                                            arc_l_attribute = self.get_l_attribute(arc)
                                            break
                                    
                                    current_traversal_count = activity_profile['traversed_arcs'].get(out_arc, 0)
                                    if current_traversal_count >= arc_l_attribute:
                                        continue
                                    
                                    # If this outgoing arc leads to sink or can reach sink, use it
                                    path_to_sink = None
                                    if out_tgt == self.sink:
                                        path_to_sink = []
                                    else:
                                        path_to_sink = self.find_path(out_tgt, self.sink, graph, set())
                                    
                                    if path_to_sink is not None:
                                        # Use this outgoing arc
                                        activity_profile['S'][timestep] = {out_arc}
                                        activity_profile['traversed_arcs'][out_arc] = activity_profile['traversed_arcs'].get(out_arc, 0) + 1
                                        activity_profile['visited_vertices'].add(out_tgt)
                                        current_vertex = out_tgt
                                        timestep += 1
                                        
                                        # Follow path to sink
                                        for path_arc in path_to_sink:
                                            current_vertex = self.add_arc_to_profile(
                                                path_arc, current_vertex, activity_profile, timestep, graph)
                                            timestep += 1
                                        
                                        # If we've reached the sink, mark as successful and return
                                        if current_vertex == self.sink:
                                            activity_profile['successful'] = True
                                            activity_profile['sink_timestep'] = timestep - 1
                                            
                                            # Clean up and return
                                            activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
                                            return activity_profile
                                except Exception as e:
                                    print(f"Error processing outgoing arc {out_arc}: {str(e)}")
                except Exception as e:
                    print(f"Error prioritizing outgoing arcs: {str(e)}")

            # Use group's max l-attribute if provided for consistent traversal patterns
            l_attribute_to_use = max_group_l_attribute if max_group_l_attribute is not None else target_l_attribute
            
            # Create a canonical complete cycle pattern
            # This ensures all arcs are included in the same consistent order
            canonical_cycle = []
            
            # Get all vertices and source->target mappings
            cycle_vertices_dict = {}
            for arc_str in standard_cycle:
                try:
                    src, tgt = arc_str.split(', ')
                    if src not in cycle_vertices_dict:
                        cycle_vertices_dict[src] = set()
                    cycle_vertices_dict[src].add(tgt)
                except Exception:
                    continue
            
            # Create a deterministic ordered pattern for the cycle
            all_vertices = set()
            for src, tgts in cycle_vertices_dict.items():
                all_vertices.add(src)
                all_vertices.update(tgts)
            
            # Sort vertices for deterministic ordering
            ordered_vertices = sorted(all_vertices)
            
            # Create a cycle pattern that visits all vertices in order
            prev_vtx = None
            for vtx in ordered_vertices:
                if prev_vtx is not None:
                    # Find path from previous vertex to current
                    vtx_path = self.find_path(prev_vtx, vtx, graph, set())
                    if vtx_path:
                        for arc in vtx_path:
                            if arc not in canonical_cycle:
                                canonical_cycle.append(arc)
                
                # Add all outgoing arcs from this vertex to the canonical cycle
                if vtx in cycle_vertices_dict:
                    for tgt in sorted(cycle_vertices_dict[vtx]):
                        arc_to_add = f"{vtx}, {tgt}"
                        if arc_to_add not in canonical_cycle:
                            canonical_cycle.append(arc_to_add)
                
                prev_vtx = vtx
            
            # Close the loop by connecting the last vertex to the first
            if prev_vtx and ordered_vertices:
                first_vtx = ordered_vertices[0]
                close_path = self.find_path(prev_vtx, first_vtx, graph, set())
                if close_path:
                    for arc in close_path:
                        if arc not in canonical_cycle:
                            canonical_cycle.append(arc)
            
            # Ensure all standard cycle arcs are included
            for arc in sorted(standard_cycle):
                if arc not in canonical_cycle:
                    canonical_cycle.append(arc)
            
            # Calculate number of cycle iterations to traverse
            # Count how many times the contract arc appears in one iteration of the cycle
            contract_arc_count_per_cycle = 0
            for arc in canonical_cycle:
                if arc == contract_arc_str:
                    contract_arc_count_per_cycle += 1
            
            # Calculate cycles needed based on l-attribute
            if contract_arc_count_per_cycle > 0:
                # Ceil division to ensure we traverse enough times
                cycles_needed = (target_l_attribute + contract_arc_count_per_cycle - 1) // contract_arc_count_per_cycle
            else:
                cycles_needed = l_attribute_to_use
                # Add the contract arc to ensure it gets traversed
                canonical_cycle.append(contract_arc_str)
                contract_arc_count_per_cycle = 1
            
            # Build the complete expanded cycle including all iterations
            # Make sure to include enough iterations to exhaust the contract arc's l-attribute
            expanded_cycle = []
            for _ in range(cycles_needed + 1):  # Add an extra iteration to be safe
                expanded_cycle.extend(canonical_cycle)
            
            # Traverse the cycle
            contract_arc_traversed = 0
            current_cycle_vertex = None
            path_to_sink_found = False
            
            for arc_idx, arc_str in enumerate(expanded_cycle):
                try:
                    src, tgt = arc_str.split(', ')
                    
                    # Initialize current vertex if not set
                    if current_cycle_vertex is None:
                        current_cycle_vertex = src
                    
                    # Skip if not at the current vertex
                    if src != current_cycle_vertex:
                        continue
                    
                    # Check if the target vertex is reachable via AND-join conditions
                    if tgt in self.join_vertices and self.join_classifications[tgt]['type'] == 'AND-JOIN':
                        # Check if all sources for this AND-join are reachable
                        unreachable_sources = []
                        for a in self.R:
                            a_str = self.get_arc(a)
                            try:
                                a_src, a_tgt = a_str.split(', ')
                                if a_tgt == tgt and self.get_c_attribute(a) != '0' and a_src != src:
                                    if not self.is_vertex_reachable_from_source(a_src) and a_src not in activity_profile['visited_vertices']:
                                        unreachable_sources.append(a_src)
                            except Exception:
                                continue
                        
                        if unreachable_sources:
                            # Can't proceed past this AND-join
                            activity_profile['deadlock'] = True
                            activity_profile['violation_cause'] = f"Deadlock at AND-join {tgt}: unreachable sources {unreachable_sources}"
                            
                            # Clean up profile and return
                            activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
                            return activity_profile
                    
                    # Check if this is the contract arc
                    if arc_str == contract_arc_str:
                        # Skip if this arc is a failed contraction
                        if contract_arc_str in self.failed_contractions:
                            # Check if we already have a starting point
                            if len(activity_profile['S']) == 0:
                                source_arc = self.get_source_arc()
                            activity_profile['deadlock'] = True
                            activity_profile['violation_cause'] = f"Contract arc {contract_arc_str} is in failed contractions"
                            
                            # Clean up profile and return
                            activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
                            return activity_profile
                        
                        # Check if we've reached the L-attribute limit
                        if contract_arc_traversed >= target_l_attribute:
                            # Don't traverse this arc anymore
                            continue
                        
                        contract_arc_traversed += 1
                    
                    # Check if we've reached the L-attribute limit for this arc
                    arc_l_attribute = 0
                    for arc in self.R:
                        if self.get_arc(arc) == arc_str:
                            arc_l_attribute = self.get_l_attribute(arc)
                            break
                    
                    current_traversal_count = activity_profile['traversed_arcs'].get(arc_str, 0)
                    if current_traversal_count >= arc_l_attribute:
                        # We've reached the L-attribute limit, can't traverse this arc anymore
                        continue
                    
                    # Process AND-JOINs specially
                    if tgt in self.join_vertices and self.join_classifications[tgt]['type'] == 'AND-JOIN':
                        # Find all incoming arcs to this join
                        join_arcs = []
                        for join_arc in self.R:
                            join_arc_str = self.get_arc(join_arc)
                            try:
                                join_src, join_tgt = join_arc_str.split(', ')
                                if join_tgt == tgt and self.get_c_attribute(join_arc) != '0':
                                    join_arcs.append(join_arc_str)
                                    
                                    # Count if this is the contract arc
                                    if join_arc_str == contract_arc_str:
                                        contract_arc_traversed += 1
                            except Exception:
                                continue
                        
                        # Add all join arcs to the same timestep
                        for join_arc in join_arcs:
                            activity_profile['S'][timestep].add(join_arc)
                            activity_profile['traversed_arcs'][join_arc] += 1
                    else:
                        # Regular arc
                        activity_profile['S'][timestep].add(arc_str)
                        activity_profile['traversed_arcs'][arc_str] += 1
                    
                    # Update current vertex and timestep
                    current_cycle_vertex = tgt
                    activity_profile['visited_vertices'].add(tgt)
                    timestep += 1
                    
                    # CRITICAL: For the contract arc, force exactly l-attribute traversals
                    if contract_arc_str and arc_str == contract_arc_str:
                        if contract_arc_traversed >= target_l_attribute:
                            # After we've traversed the contract arc exactly l-attribute times,
                            # find a path to the sink
                            path_to_sink = self.find_path(current_cycle_vertex, self.sink, graph, set())
                            if path_to_sink:
                                for path_arc in path_to_sink:
                                    # Inline arc addition logic
                                    try:
                                        p_src, p_tgt = path_arc.split(', ')
                                        
                                        # Check L-attribute limit
                                        arc_l_attribute = 0
                                        for arc in self.R:
                                            if self.get_arc(arc) == path_arc:
                                                arc_l_attribute = self.get_l_attribute(arc)
                                                break
                                        
                                        current_traversal_count = activity_profile['traversed_arcs'].get(path_arc, 0)
                                        if current_traversal_count >= arc_l_attribute:
                                            # L-attribute limit reached, mark deadlock
                                            activity_profile['deadlock'] = True
                                            activity_profile['violation_cause'] = f"Arc {path_arc} has reached its L-attribute limit of {arc_l_attribute}"
                                            break
                                        
                                        # Handle AND-joins
                                        if p_tgt in self.join_vertices and self.join_classifications[p_tgt]['type'] == 'AND-JOIN':
                                            # For AND-JOIN, check if all incoming sources are reachable
                                            unreachable_sources = []
                                            
                                            # Find all incoming arcs with non-epsilon c-attributes
                                            non_epsilon_sources = []
                                            for a in self.R:
                                                a_str = self.get_arc(a)
                                                try:
                                                    a_src, a_tgt = a_str.split(', ')
                                                    if a_tgt == p_tgt and self.get_c_attribute(a) != '0':
                                                        non_epsilon_sources.append(a_src)
                                                        # Check if this source is reachable from the starting point
                                                        if a_src not in activity_profile['visited_vertices'] and not self.is_vertex_reachable_from_source(a_src):
                                                            unreachable_sources.append(a_src)
                                                except Exception:
                                                    continue
                                            
                                            # If any source is unreachable, mark as deadlock
                                            if unreachable_sources:
                                                activity_profile['deadlock'] = True
                                                activity_profile['violation_cause'] = f"Deadlock at AND-join {p_tgt}: unreachable sources {unreachable_sources}"
                                                break
                                            
                                            # If all sources are either visited or reachable, proceed with the join
                                            if all(s in activity_profile['visited_vertices'] or s == current_cycle_vertex for s in non_epsilon_sources):
                                                # Add all join arcs to the same timestep
                                                for a in self.R:
                                                    a_str = self.get_arc(a)
                                                    try:
                                                        a_src, a_tgt = a_str.split(', ')
                                                        if a_tgt == p_tgt and self.get_c_attribute(a) != '0':
                                                            # Check L-attribute limit for each join arc
                                                            a_l_attribute = self.get_l_attribute(a)
                                                            a_traversal_count = activity_profile['traversed_arcs'].get(a_str, 0)
                                                            if a_traversal_count < a_l_attribute:
                                                                activity_profile['S'][timestep].add(a_str)
                                                                activity_profile['traversed_arcs'][a_str] += 1
                                                    except Exception:
                                                        continue
                                                    
                                                activity_profile['visited_vertices'].add(p_tgt)
                                                current_cycle_vertex = p_tgt
                                            else:
                                                # Not all sources visited yet
                                                break
                                        else:
                                            # Regular arc
                                            activity_profile['S'][timestep].add(path_arc)
                                            activity_profile['traversed_arcs'][path_arc] += 1
                                            activity_profile['visited_vertices'].add(p_tgt)
                                            current_cycle_vertex = p_tgt
                                    except Exception as e:
                                        print(f"Error processing arc {path_arc}: {str(e)}")
                                        break
                                    
                                    timestep += 1
                
                except Exception as e:
                    print(f"Error processing arc {arc_str}: {str(e)}")
                    continue
            
            # If we haven't found a path to the sink yet, try now
            if not path_to_sink_found and current_cycle_vertex:
                path_to_sink = self.find_path(current_cycle_vertex, self.sink, graph, set())
                if path_to_sink:
                    for path_arc in path_to_sink:
                        # Inline the add_arc_to_profile functionality
                        try:
                            src, tgt = path_arc.split(', ')
                            
                            # Check if we've already reached the L-attribute limit for this arc
                            arc_l_attribute = 0
                            for arc in self.R:
                                if self.get_arc(arc) == path_arc:
                                    arc_l_attribute = self.get_l_attribute(arc)
                                    break
                            
                            current_traversal_count = activity_profile['traversed_arcs'].get(path_arc, 0)
                            if current_traversal_count >= arc_l_attribute:
                                # We've reached the L-attribute limit, can't traverse this arc anymore
                                activity_profile['deadlock'] = True
                                activity_profile['violation_cause'] = f"Arc {path_arc} has reached its L-attribute limit of {arc_l_attribute}"
                                continue
                            
                            # Check for joins
                            if tgt in self.join_vertices and self.join_classifications[tgt]['type'] == 'AND-JOIN':
                                # For AND-JOIN, check if all incoming sources are reachable
                                unreachable_sources = []
                                
                                # Find all incoming arcs with non-epsilon c-attributes
                                non_epsilon_sources = []
                                for a in self.R:
                                    a_str = self.get_arc(a)
                                    try:
                                        a_src, a_tgt = a_str.split(', ')
                                        if a_tgt == tgt and self.get_c_attribute(a) != '0':
                                            non_epsilon_sources.append(a_src)
                                            # Check if this source is reachable from the starting point
                                            if a_src not in activity_profile['visited_vertices'] and not self.is_vertex_reachable_from_source(a_src):
                                                unreachable_sources.append(a_src)
                                    except Exception:
                                        continue
                                
                                # If any source is unreachable, mark as deadlock
                                if unreachable_sources:
                                    activity_profile['deadlock'] = True
                                    activity_profile['violation_cause'] = f"Deadlock at AND-join {tgt}: unreachable sources {unreachable_sources}"
                                    continue
                                
                                # If all sources are either visited or reachable, proceed with the join
                                if all(s in activity_profile['visited_vertices'] or s == current_cycle_vertex for s in non_epsilon_sources):
                                    # Add all join arcs to the same timestep
                                    for a in self.R:
                                        a_str = self.get_arc(a)
                                        try:
                                            a_src, a_tgt = a_str.split(', ')
                                            if a_tgt == tgt and self.get_c_attribute(a) != '0':
                                                # Check L-attribute limit for each join arc
                                                a_l_attribute = self.get_l_attribute(a)
                                                a_traversal_count = activity_profile['traversed_arcs'].get(a_str, 0)
                                                if a_traversal_count < a_l_attribute:
                                                    activity_profile['S'][timestep].add(a_str)
                                                    activity_profile['traversed_arcs'][a_str] += 1
                                        except Exception:
                                            continue
                                    
                                    activity_profile['visited_vertices'].add(tgt)
                                    current_cycle_vertex = tgt
                                else:
                                    # Can't traverse yet - not all sources have been visited
                                    continue
                            else:
                                # Regular arc
                                activity_profile['S'][timestep].add(path_arc)
                                activity_profile['traversed_arcs'][path_arc] += 1
                                activity_profile['visited_vertices'].add(tgt)
                                current_cycle_vertex = tgt
                        except Exception as e:
                            print(f"Error processing arc {path_arc}: {str(e)}")
                            continue
                        
                        timestep += 1
                
                # Mark as successful if we reached the sink
                if current_cycle_vertex == self.sink:
                    activity_profile['successful'] = True
                    activity_profile['sink_timestep'] = timestep - 1
        
        # Clean up empty timesteps
        activity_profile['S'] = {k: v for k, v in activity_profile['S'].items() if v}
        
        # Print arc usage info
        # print("\nArc Usage (traversed/limit):")
        all_arcs = {self.get_arc(arc): self.get_l_attribute(arc) for arc in self.R}
        for arc_str, limit in sorted(all_arcs.items()):
            used = activity_profile['traversed_arcs'].get(arc_str, 0)
            # print(f"{arc_str}: {used}/{limit}")
        
        # Extra verification step - always check if we've visited the sink
        if self.sink in activity_profile['visited_vertices']:
            activity_profile['successful'] = True
            
            # If sink_timestep isn't set, try to determine it
            if activity_profile['sink_timestep'] is None:
                # Look through all arcs to find the first one that targets the sink
                for ts, arcs in sorted(activity_profile['S'].items()):
                    for arc in arcs:
                        try:
                            _, tgt = arc.split(', ')
                            if tgt == self.sink:
                                activity_profile['sink_timestep'] = ts
                                break
                        except Exception:
                            continue
                    if activity_profile['sink_timestep'] is not None:
                        break
                
                # If we still don't have a timestamp, use the last one
                if activity_profile['sink_timestep'] is None and activity_profile['S']:
                    activity_profile['sink_timestep'] = max(activity_profile['S'].keys())
        
        return activity_profile

    def find_path(self, start_vertex, end_vertex, graph, visited=None):
        """
        Find a path from start vertex to end vertex using depth-first search.
        
        This method uses DFS to find a valid path between two vertices in the graph,
        respecting constraints like unreachable vertices and failed contractions.
        
        Parameters:
            start_vertex (str): The starting vertex for the path.
            end_vertex (str): The target vertex for the path.
            graph (dict): The graph representation as adjacency list.
            visited (set, optional): Set of already visited vertices to prevent cycles. Defaults to None.
            
        Returns:
            list/None: A list of arc strings representing the path if found, None otherwise.
        """
        if visited is None:
            visited = set()
        
        # Base cases
        if start_vertex == end_vertex:
            return []
        
        if start_vertex in visited:
            return None  # Already visited, avoid cycles
        
        # Mark as visited
        visited.add(start_vertex)
        
        # Recursively explore neighbors
        if start_vertex in graph:
            # Sort neighbors to ensure deterministic path selection
            neighbors = sorted([(next_vertex, arc) for next_vertex, arc in graph[start_vertex]], 
                               key=lambda x: x[0])
            
            for next_vertex, arc in neighbors:
                # Skip if already visited
                if next_vertex in visited:
                    continue
                
                # Check if the next vertex is even reachable from source
                if not self.is_vertex_reachable_from_source(next_vertex):
                    continue
                
                arc_str = self.get_arc(arc)
                
                # Skip if this arc is in failed contractions
                if arc_str in self.failed_contractions:
                    continue
                
                # Create a new copy of visited for each branch
                next_path = self.find_path(next_vertex, end_vertex, graph, visited.copy())
                if next_path is not None:
                    return [arc_str] + next_path
        
        return None

    def get_l_attribute(self, arc):
        """
        Get the L-attribute (traversal limit) of an arc.
        
        The L-attribute specifies how many times an arc can be traversed during execution.
        
        Parameters:
            arc (dict/str): The arc to get the L-attribute for.
            
        Returns:
            int: The L-attribute value, defaulting to 1 if not specified.
        """
        # Find the matching arc in self.R
        for r_arc in self.R:
            if self.get_arc(r_arc) == self.get_arc(arc):
                return int(r_arc.get('l-attribute', 1) if isinstance(r_arc, dict) else 1)
        return 1  # Default if no match found

    def get_c_attribute(self, arc):
        """
        Get the C-attribute (join requirement) of an arc.
        
        The C-attribute determines whether an arc requires other incoming arcs to be traversed
        before it can be traversed (used in AND-JOIN vertices).
        
        Parameters:
            arc (dict/str): The arc to get the C-attribute for.
            
        Returns:
            str: The C-attribute value, defaulting to '0' if not specified.
        """
        # Find the matching arc in self.R
        for r_arc in self.R:
            if self.get_arc(r_arc) == self.get_arc(arc):
                return r_arc.get('c-attribute', '0') if isinstance(r_arc, dict) else '0'
        return '0'  # Default if no match found
    
    def get_arc(self, arc_data):
        """
        Extract the arc string from various possible arc data formats.
        
        This utility method handles different representations of arcs in the codebase,
        ensuring a consistent string format is used.
        
        Parameters:
            arc_data (dict/str/tuple): The arc data in various possible formats.
            
        Returns:
            str: The standardized arc string in the format "source, target".
        """
        if isinstance(arc_data, str):
            return arc_data
        elif isinstance(arc_data, dict):
            return arc_data.get('arc', str(arc_data))
        return str(arc_data)

    def print_activity_profiles(self):
        """
        Print all activity profiles.
        """
        # Process profiles in a deterministic order
        for contract_arc, activity_profile in sorted(self.activity_profiles.items(), key=lambda x: str(x[0])):
            print(f"\n--- Activity Profile for ({contract_arc}) ---")
            self.print_activity_profile(activity_profile)

    def convert_arc_format(self, arc):
        """
        Convert an arc to a consistent string format.
        
        This utility method ensures arcs are represented in a standard format regardless
        of their original representation (string, tuple, etc.).
        
        Parameters:
            arc (str/tuple/list): The arc in various possible formats.
            
        Returns:
            str: The standardized arc string in the format "(source, target)".
        """
        if isinstance(arc, str):
            # Handle string format like "a, b"
            return f"({arc.split(', ')[0]}, {arc.split(', ')[1]})"
        elif isinstance(arc, (tuple, list)) and len(arc) == 2:
            # Handle tuple or list format
            return f"({arc[0]}, {arc[1]})"
        else:
            return str(arc)  # fallback for unexpected formats

    def convert_arc_list_format(self, arc_list):
        """
        Convert a list of arcs to a consistent format.
        
        This utility method applies convert_arc_format to each arc in a list,
        ensuring deterministic ordering.
        
        Parameters:
            arc_list (list): List of arcs in various formats.
            
        Returns:
            list: List of standardized arc strings, sorted for deterministic order.
        """
        # Ensure deterministic order
        return [self.convert_arc_format(arc) for arc in sorted(arc_list, key=str)]

    def print_activity_profile(self, activity_profile):
        """
        Print a activity profile and reachability configurations.
        
        This method displays the steps, arcs traversed, and status information from an activity
        profile, providing insight into the execution behavior of the RDLT.
        
        Parameters:
            activity_profile (dict): The activity profile to print.
        """
        if 'S' not in activity_profile:
            print("Invalid activity profile: Missing 'S' key")
            return

        # Process timesteps in deterministic order
        for timestep, arcs in sorted(activity_profile['S'].items()):
            # Ensure deterministic order of arcs within each timestep
            print(f"S({timestep}) = {self.convert_arc_list_format(set(arcs))}")

        if activity_profile['S']:
            print("\nS = {" + ", ".join(f"S({ts})" for ts in sorted(activity_profile['S'].keys())) + "}")
        
        # Get the last timestep for consistent reporting
        last_timestep = max(activity_profile['S'].keys()) if activity_profile['S'] else 0
        
        # Print any notes about alternative paths
        if activity_profile.get('note'):
            print(f"\n{activity_profile['note']}")
        
        # Check if sink was actually reached by examining the visited vertices
        sink_reached = self.sink in activity_profile.get('visited_vertices', set())
        
        # Show sink status based on whether it was reached
        if sink_reached:
            sink_timestep = activity_profile.get('sink_timestep', last_timestep)
            print(f"\nSink was reached at timestep {sink_timestep}")
        elif activity_profile.get('deadlock', False):
            print(f"\nSink was not reached (deadlock after timestep {last_timestep})")
            # if activity_profile.get('violation_cause'):
            #     print(f"Reason: {activity_profile['violation_cause']}")
        else:
            # Neither deadlock nor successful - sink was simply not reached
            print(f"\nSink was not reached (deadlock after timestep {last_timestep})")
            # if activity_profile.get('violation_cause'):
            #     print(f"Note: {activity_profile['violation_cause']}")

    def get_source_arc(self):
        """
        Get the arc originating from the source vertex.
        
        This utility method finds the first arc that starts at the source vertex,
        which is useful for initializing activity profiles.
        
        Returns:
            str: The arc string for the first arc from the source vertex.
        """
        for arc in self.R:
            arc_str = self.get_arc(arc)
            try:
                src, _ = arc_str.split(', ')
                if src == self.source:
                    return arc_str
            except Exception:
                continue
        # Fallback if no source arc found
        return f"({self.source}, unknown)"

    def find_path_in_adjacency(self, start_vtx, end_vtx, adjacency, visited=None):
        """
        Find a path between vertices using an adjacency list representation.
        
        This is an alternative path-finding method that uses an adjacency list rather than
        the graph representation used in find_path.
        
        Parameters:
            start_vtx (str): The starting vertex.
            end_vtx (str): The target vertex.
            adjacency (dict): The graph as an adjacency list.
            visited (set, optional): Set of already visited vertices. Defaults to None.
            
        Returns:
            list/None: A list of vertices representing the path if found, None otherwise.
        """
        if visited is None:
            visited = set()
        
        if start_vtx == end_vtx:
            return []
        
        if start_vtx in visited:
            return None
        
        visited.add(start_vtx)
        
        if start_vtx in adjacency:
            for tgt, arc_str in sorted(adjacency[start_vtx], key=lambda x: x[0]):
                if tgt not in visited:
                    path = self.find_path_in_adjacency(tgt, end_vtx, adjacency, visited.copy())
                    if path is not None:
                        return [arc_str] + path
        
        return None